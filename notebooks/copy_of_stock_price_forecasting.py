# -*- coding: utf-8 -*-
"""Copy of STOCK_PRICE_FORECASTING.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJFKLcrVk5Y5aKTOu5UpmcW1hPnEpjmF

# ðŸ“ˆ Stock Price Forecasting using LSTM (Close Price Baseline)

## ðŸ§  Project Overview

This project implements a Long Short-Term Memory (LSTM) model to forecast the next-day closing price of a stock using historical closing prices. The problem is formulated as a Many-to-One time-series regression task, where the past 60 trading days are used to predict the following dayâ€™s close. The dataset is obtained from Yahoo Finance and processed using chronological splitting to prevent data leakage. A naive persistence baseline (tomorrow = today) is used for performance comparison to ensure realistic evaluation. The goal of this baseline model is to establish a structured foundation before introducing additional financial features or multivariate inputs.

## ðŸŽ¯ Objective

The primary objective of this baseline model is to predict the next-day closing price using only historical closing values. By focusing solely on the Close feature, we create a clean and interpretable starting point for time-series modeling. This approach allows us to evaluate whether an LSTM can outperform a simple naive forecasting strategy. The model is assessed using regression metrics such as RMSE and MAE to measure predictive accuracy. Establishing this baseline is critical before extending the system to multivariate forecasting or advanced financial analysis.

Install Dependencies
"""

!pip install yfinance

"""Imports"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

import yfinance as yf

from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

"""Download Dataset"""

ticker = "AAPL"
start_date = "2010-01-01"
end_date = "2027-01-01"

data = yf.download(ticker, start=start_date, end=end_date)

data.tail()

data.shape

"""Select Close Price Only"""

data = data[['Close']]
data.dropna(inplace=True)

plt.figure(figsize=(12,6))
plt.plot(data)
plt.title("Closing Price")
plt.show()

ma100 = data.Close.rolling(50).mean()
ma100

ma200 = data.Close.rolling(100).mean()
ma200

plt.figure(figsize = (12,6))
plt.plot(data.Close)
plt.plot(ma100, 'r')
plt.grid(True)
plt.title('Graph Of Moving Averages Of 50 Days')

plt.figure(figsize = (12,6))
plt.plot(data.Close)
plt.plot(ma100, 'r')
plt.plot(ma200, 'g')
plt.grid(True)
plt.title('Comparision Of 50 Days And 100 Days Moving Averages')

"""Train-Test Split (Chronological!)"""

train_size = int(len(data) * 0.8)

train_data = data[:train_size]
test_data = data[train_size:]

"""Scaling"""

scaler = MinMaxScaler(feature_range=(0,1))

train_scaled = scaler.fit_transform(train_data)
test_scaled = scaler.transform(test_data)

"""Sliding Window Function"""

def create_sequences(data, window_size):
    X = []
    y = []

    for i in range(window_size, len(data)):
        X.append(data[i-window_size:i])
        y.append(data[i])

    return np.array(X), np.array(y)

WINDOW_SIZE = 100

X_train, y_train = create_sequences(train_scaled, WINDOW_SIZE)
X_test, y_test = create_sequences(test_scaled, WINDOW_SIZE)

print("X_train shape:", X_train.shape)
print("y_train shape:", y_train.shape)

"""Build LSTM Model"""

model = Sequential([
    LSTM(80, return_sequences=False, input_shape=(WINDOW_SIZE,1)),
    Dropout(0.2),
    Dense(1)
])

model.compile(
    optimizer='adam',
    loss='mse'
)

model.summary()

"""Train Model"""

history = model.fit(
    X_train,
    y_train,
    epochs=100,
    batch_size=32,
    validation_split=0.1
)

"""Predict"""

predictions = model.predict(X_test)

# Inverse scaling
predictions = scaler.inverse_transform(predictions)
y_test_actual = scaler.inverse_transform(y_test)

"""Evaluation Metrics"""

rmse = np.sqrt(mean_squared_error(y_test_actual, predictions))
mae = mean_absolute_error(y_test_actual, predictions)

print("RMSE:", rmse)
print("MAE:", mae)

"""Visualization"""

plt.figure(figsize=(14,6))
plt.plot(y_test_actual, label="Actual")
plt.plot(predictions, label="Predicted")
plt.legend()
plt.title("Actual vs Predicted Stock Price")
plt.show()

"""Naive Baseline"""

naive_predictions = y_test_actual[:-1]
naive_actual = y_test_actual[1:]

naive_rmse = np.sqrt(mean_squared_error(naive_actual, naive_predictions))

print("Naive RMSE:", naive_rmse)

data['Returns'] = data['Close'].pct_change()
data['Returns'].hist(bins=50)

data['Return'] = data['Close'].pct_change()
data.dropna(inplace=True)

data['Return'].autocorr()

direction_pred = np.sign(predictions)
direction_actual = np.sign(y_test_actual)

accuracy = np.mean(direction_pred == direction_actual)

model.save('stock_prediction_model.keras')

last_window = data['Close'].iloc[-WINDOW_SIZE:].values
last_window_scaled = scaler.transform(last_window.reshape(-1, 1))

X_predict = np.array([last_window_scaled])

tomorrow_price_scaled = model.predict(X_predict)
tomorrow_price = scaler.inverse_transform(tomorrow_price_scaled)

print(f"Predicted stock price for tomorrow: {tomorrow_price[0][0]:.2f}")

from sklearn.metrics import r2_score

# Calculate R2 Score
r2 = r2_score(y_test_actual, predictions)

print("MAE:", mae)
print("RMSE:", rmse)
print("R2 Score:", r2)

# Visualization
plt.figure(figsize=(14,6))
plt.plot(y_test_actual, label="Actual")
plt.plot(predictions, label="Predicted")
plt.legend()
plt.title("Actual vs Predicted Stock Price")
plt.show()

"""# Task
Predict and visualize the next 5 days of stock prices using the trained model, then summarize the predictions.

## Predict Next Week's Prices

### Subtask:
Generate predictions for the next 5 trading days by iteratively using the model. Each new prediction will be appended to the input sequence for the next day's prediction.

**Reasoning**:
First, I'll extract the last `WINDOW_SIZE` closing prices from the `data` DataFrame and scale them using the previously fitted `scaler`. This will form the initial input sequence for the iterative prediction process.
"""

last_window = data['Close'].iloc[-WINDOW_SIZE:].values
current_input_sequence = scaler.transform(last_window.reshape(-1, 1))

next_5_days_predictions = []

print("Initial current_input_sequence shape:", current_input_sequence.shape)

"""**Reasoning**:
Now, I will iterate 5 times to predict the next 5 trading days, each time using the model to predict the next value, inverse transforming it, and updating the input sequence for the subsequent prediction.


"""

for _ in range(5):
    # Reshape the current input sequence for the model
    X_predict = current_input_sequence.reshape(1, WINDOW_SIZE, 1)

    # Predict the next day's price (scaled)
    next_day_scaled_prediction = model.predict(X_predict)

    # Inverse transform the scaled prediction to get the actual price
    next_day_price = scaler.inverse_transform(next_day_scaled_prediction)

    # Append the actual predicted price to our list
    next_5_days_predictions.append(next_day_price[0][0])

    # Update the input sequence: remove the first element and add the new scaled prediction
    current_input_sequence = np.append(current_input_sequence[1:], next_day_scaled_prediction, axis=0)

print("Predicted next 5 days stock prices:", next_5_days_predictions)

"""**Reasoning**:
Now, I will prepare the data for visualization. This involves getting the last 'WINDOW_SIZE' days of actual data, and then concatenating the actual prices with the predicted prices for the next 5 days. This will create a continuous sequence for plotting.


"""

last_window_actual_prices = data['Close'].iloc[-WINDOW_SIZE:].values

# Create a date range for the predicted days starting from the day after the last actual data point
last_date = data.index[-1]
predicted_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=5, freq='B') # 'B' for business day

# Combine actual historical data with predicted future prices and their dates
future_predictions_series = pd.Series(next_5_days_predictions, index=predicted_dates)

# For visualization, we might want to show some recent historical data leading up to the predictions
plot_data = data['Close'].tail(WINDOW_SIZE).copy()
full_plot_series = pd.concat([plot_data, future_predictions_series])

print("Full plot series head:", full_plot_series.head())
print("Full plot series tail:", full_plot_series.tail())

"""**Reasoning**:
I will visualize the actual historical prices alongside the predicted 5-day stock prices to provide a clear understanding of the model's forecast.


"""

plt.figure(figsize=(15, 7))
plt.plot(plot_data.index, plot_data.values, label='Historical Prices', color='blue')
plt.plot(future_predictions_series.index, future_predictions_series.values, label='Predicted Prices (Next 5 Days)', color='red', linestyle='--')
plt.title('Stock Price Prediction: Historical vs. Next 5 Days Forecast')
plt.xlabel('Date')
plt.ylabel('Close Price')
plt.legend()
plt.grid(True)
plt.show()

"""### Summary of Next 5 Days Predictions

Based on the LSTM model, the predicted closing prices for the next 5 trading days are:

* **Day 1:** `256.02`
* **Day 2:** `253.41`
* **Day 3:** `251.57`
* **Day 4:** `249.96`
* **Day 5:** `248.43`

The predictions show a gradual decrease in stock price over the next five trading days. It is important to note that these are model-generated forecasts and actual market movements can vary.

## Summary:

### Data Analysis Key Findings
*   The LSTM model predicted the following closing prices for the next 5 trading days:
    *   Day 1: \$256.02
    *   Day 2: \$253.41
    *   Day 3: \$251.57
    *   Day 4: \$249.96
    *   Day 5: \$248.43
*   The predictions indicate a gradual downward trend in the stock price over the forecast period, with the price decreasing from \$256.02 on Day 1 to \$248.43 on Day 5.
*   The predictions were successfully visualized alongside recent historical data, showing a clear continuation of the historical trend into the forecast period.

### Insights or Next Steps
*   The model predicts a bearish short-term outlook for the stock. This information could be used for short-term trading strategies or risk assessment.
*   To improve model robustness and prediction accuracy, consider incorporating additional features like trading volume, sentiment analysis, or macroeconomic indicators, and exploring different LSTM architectures or hyperparameter tuning.

## Multivariate OHLC Setup

Use OHLC
"""

# Re-download the full OHLC data to ensure all features are present for multivariate analysis
ohlc_full_data = yf.download(ticker, start=start_date, end=end_date)
ohlc_full_data.dropna(inplace=True) # Drop rows with any missing OHLC values

features = ['Open', 'High', 'Low', 'Close']
data_ohlc = ohlc_full_data[features].copy()

train_size = int(len(data_ohlc) * 0.8)

train_data = data_ohlc[:train_size]
test_data = data_ohlc[train_size:]

"""Scale All Features"""

scaler = MinMaxScaler()

train_scaled = scaler.fit_transform(train_data)
test_scaled = scaler.transform(test_data)

"""Create Sequences (Multivariate)"""

WINDOW_SIZE = 60

def create_sequences_multi(data, window_size):
    X = []
    y = []
    for i in range(window_size, len(data)):
        X.append(data[i-window_size:i])
        y.append(data[i])
    return np.array(X), np.array(y)

X_train, y_train = create_sequences_multi(train_scaled, WINDOW_SIZE)
X_test, y_test = create_sequences_multi(test_scaled, WINDOW_SIZE)

print("X_train:", X_train.shape)
print("y_train:", y_train.shape)

"""Build Multi-Output LSTM"""

model = Sequential([
    LSTM(64, return_sequences=False, input_shape=(WINDOW_SIZE, 4)),
    Dropout(0.2),
    Dense(32, activation='relu'),
    Dense(4)  # Predict Open, High, Low, Close
])

model.compile(optimizer='adam', loss='mse')

model.summary()

"""Train"""

history = model.fit(
    X_train,
    y_train,
    epochs=20,
    batch_size=32,
    validation_split=0.1
)

"""Predict Test Set"""

predictions = model.predict(X_test)

predictions = scaler.inverse_transform(predictions)
y_test_actual = scaler.inverse_transform(y_test)

"""Compute Metrics (Close only)"""

rmse = np.sqrt(mean_squared_error(
    y_test_actual[:,3],
    predictions[:,3]
))

print("Close RMSE:", rmse)

"""5-Day Recursive Forecast"""

last_window = train_scaled[-WINDOW_SIZE:]
future_predictions = []

current_window = last_window.copy()

for _ in range(5):
    pred = model.predict(np.array([current_window]))
    future_predictions.append(pred[0])

    current_window = np.vstack((current_window[1:], pred))

future_predictions = scaler.inverse_transform(np.array(future_predictions))

print("Predicted future prices:", future_predictions)

"""Technical Indicators"""

data['MA20'] = data['Close'].rolling(20).mean()
data['MA50'] = data['Close'].rolling(50).mean()
data['Return'] = data['Close'].pct_change()
data['Volatility'] = data['Return'].rolling(20).std()

residuals = y_test_actual[:,3] - predictions[:,3]
sigma = np.std(residuals)

future_close = future_predictions[:,3]

upper_band = future_close + 1.96 * sigma
lower_band = future_close - 1.96 * sigma